这是一个基于 **Rust + TUI (Text User Interface)** 架构的详细实现方案。针对你追求的“无图标、全键盘操作、类似 fzf 的极速体验”，我们将对现有代码进行核心重构。

此方案将侧重于**架构逻辑**、**数据流向**和**关键交互细节**，帮助你构建一个健壮的命令行启动器。

---

### 一、 核心架构重构

目前的 `main.rs` 是一个简单的“读取-求值-打印”循环（REPL）。我们需要将其转换为一个**即时模式（Immediate Mode）的事件驱动架构**。

#### 1. 引入 TUI 生态

我们需要引入 Rust TUI 领域的两大基石库，替换原有的 `console` 库：

* **`ratatui`**: 负责**绘制**。它提供了布局系统（Layout）、组件（Widgets如列表、输入框）和渲染逻辑。它是目前最流行的 TUI 框架。
* **`crossterm`**: 负责**底层控制**。它处理键盘输入（事件捕获）、终端 Raw 模式（禁用回显、接管按键）以及屏幕缓冲区的切换。

#### 2. 状态管理 (State Management)

TUI 应用本质上是一个状态机。你需要定义一个全局的 UI 状态结构体（建议放在 `state.rs` 中），用于在每一帧渲染时描述界面长什么样。

**核心字段设计：**

* **输入状态 (`input`)**: 一个 `String`，存储用户当前输入的字符。
* **输入光标 (`cursor_x`)**: 记录光标在输入框中的位置（方便支持左右移动光标修改中间的字符）。
* **结果列表 (`results`)**: 当前搜索匹配到的 `Vec<SearchResult>`。
* **列表选中态 (`list_state`)**: `ratatui` 特有的结构，用于记录当前高亮的是第几行，并处理滚动条位置。
* **退出标记 (`should_quit`)**: 布尔值，控制主循环是否结束。
* **待执行动作 (`pending_action`)**: 当用户按下回车时，将选中的动作存入此处，然后退出 UI 循环。

---

### 二、 详细实现流程

#### 阶段 1：初始化与终端接管

这是程序启动的第一步，必须处理好“现场保护”。

1. **数据加载**：并行加载索引和配置（沿用你现有的逻辑）。
2. **进入 Raw Mode**：调用 `crossterm` 的 `enable_raw_mode()`。

* 这会禁用控制台的行缓冲（Line Buffering），让程序能捕获每一个按键，而不是等用户按回车。
* 禁用回显（Echo），用户打字不会直接显示在屏幕上，而是通过你的程序绘制出来。

1. **切换屏幕**：进入 `Alternate Screen`（备用屏幕缓冲区）。这能让你的程序独占全屏，退出后原有的终端内容（如之前的命令历史）完好无损。
2. **隐藏光标**：TUI 通常会由组件自己绘制光标，或者你可以精确控制系统光标的位置。

#### 阶段 2：主事件循环 (The Event Loop)

这是程序的心脏，通常以 `60 FPS` 或按需刷新的方式运行。

**循环体内的逻辑顺序：**

1. **绘制 (Draw)**：

* 调用 `terminal.draw()`。
* 使用 `Layout` 将屏幕垂直切分为两部分：
* **顶部/底部 (Input Area)**：固定高度（如 3 行），显示输入框。
* **剩余区域 (List Area)**：显示搜索结果列表。

* 根据 `State` 中的数据渲染 `Paragraph` (输入框) 和 `List` (结果)。
* *关键点*：根据 `list_state` 渲染高亮行，确保高亮行始终在可视区域内（自动滚动）。

1. **事件捕获 (Poll & Handle)**：

* 使用 `crossterm::event::poll` 检查是否有按键输入（设置一个极短的超时，如 16ms，以保持 UI 响应但不占用 100% CPU）。
* 如果有事件，读取 `read()` 并匹配按键：
* **字符键 (Char)**：
* 将字符追加到 `input` 字符串。
* **立即触发搜索**：调用 `search_core::search(input)`，更新 `results`。
* **重置选中项**：搜索结果变了，光标应自动回到第一项 (Index 0)。

* **退格键 (Backspace)**：
* 从 `input` 移除最后一个字符。
* **立即触发搜索**。

* **上下箭头 (Up / Down)**：
* 修改 `list_state` 的选中索引。
* 实现**循环滚动**：在第一项按“上”跳到最后一项，反之亦然。

* **回车键 (Enter)**：
* 获取当前 `list_state` 选中的索引。
* 从 `results` 中找到对应的动作。
* 将动作存入 `pending_action`。
* 设置 `should_quit = true`，准备退出循环。

* **ESC 键**：
* 设置 `should_quit = true`，不保存动作。

#### 阶段 3：资源释放与动作执行

这是 TUI 应用最容易出 Bug 的地方。**必须先恢复终端，再执行动作**。

1. **退出 Raw Mode**：`disable_raw_mode()`。
2. **切回主屏幕**：离开 `Alternate Screen`。
3. **显示光标**。
4. **执行动作**：

* 检查 `pending_action` 是否有值。
* 如果有，调用 `execute::execute_action(...)`。
* *原因*：如果你在 TUI 模式下直接启动一个控制台程序（如 vim 或 ping），它们会因为终端处于 Raw 模式而显示错乱。必须先彻底恢复终端环境。

---

### 三、 交互体验优化细节 (fzf 风格)

为了达到极致的“手感”，请注意以下细节的实现：

1. **去抖动 (Debounce) 的取舍**：

* 在 GUI 中通常需要防抖（等用户停手 200ms 再搜）。
* 但在 Rust TUI 中，由于纯文本搜索极快（由 `fuzzy-matcher` 提供），对于 10 万级以下的数据量，建议**不做防抖**。用户每按键一次，立即更新列表，这种“跟手”的感觉非常重要。

1. **视觉层级**：

* **输入框**：使用不同颜色的边框（如黄色）表示这是焦点。
* **选中行**：使用反色（背景蓝，前景白）或行首添加 `>` 符号来明确指示当前选中项。
* **结果项**：
* 第一行：应用名称（高亮/粗体）。
* 第二行（可选）：路径或描述（暗灰色），提供辅助信息。

1. **智能排序**：

* 当 `input` 为空时，不要显示空白，而是显示“最近使用”或“高频应用”列表（LRU Cache）。这能大幅提升重复操作的效率。

1. **快捷键增强**：

* `Ctrl+N` / `Ctrl+P`：映射为 下/上，方便 Emacs/Vim 用户。
* `Ctrl+W`：删除前一个单词（快速清除输入）。
* `Ctrl+C`：强制退出。

### 四、 涉及的文件修改建议

1. **`Cargo.toml`**:

* 添加 `ratatui` 和 `crossterm`。
* 移除 `console`。

1. **`src/main.rs`**:

* 完全重写。移除 `run_repl` 函数。
* 引入 `App` 结构体和 `run_app` 循环逻辑。
* 将初始化逻辑和 UI 循环逻辑分离。

1. **`src/state.rs`**:

* 扩充 `AppState`，或者新建 `TuiState` 专门服务于 UI 渲染。
* 引入 `ratatui::widgets::ListState`。

1. **`src/search_core.rs`**:

* 保持核心逻辑不变，但确保它是无副作用的（Pure Function），仅接受 query 和 index，返回 results。

1. **`src/execute.rs`**:

* 确保 `execute_action` 是同步阻塞的或者能被主线程正确调用，不需要改动太多逻辑，但要确保它在 `disable_raw_mode` 之后运行。

按照这个方案，你将得到一个启动速度极快、占用内存极低、完全键盘驱动的 Windows 生产力工具。
